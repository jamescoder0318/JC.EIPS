---
eip: 4895
title: Beacon chain push withdrawals as operations
description: Support validator withdrawals from the beacon chain to the EVM via a new "system-level" operation type.
author: Alex Stokes (@ralexstokes), Danny Ryan (@djrtwo)
discussions-to: https://ethereum-magicians.org/t/eip-4895-beacon-chain-withdrawals-as-system-level-operations/8568
status: Draft
type: Standards Track
category: Core
created: 2022-03-10
---

## Abstract

Introduce a system-level "operation" to support validator withdrawals that are "pushed" from the beacon chain to the EVM.

These operations effect unconditional balance increases to the specified recipients.

## Motivation

This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM.
The architecture is "push"-based, rather than "pull"-based, where withdrawals are required to be processed in the execution block as soon as they are dequeued from the beacon chain.

This approach is more involved than "pull"-based alternatives (e.g. [EIP-4788](./eip-4788.md) + user-space withdrawal contract) with respect to the core protocol (by providing a new object type -- operation -- with special semantics) but does provide tighter integration of a critical feature into the protocol itself.

Additionally, the withdrawals themselves are represented as a new type of object in the block -- an "operation" -- that keeps their concern separate from user-level transactions.
This approach is more involved than the prior [EIP-4863](./eip-4863.md) but it cleanly separates this "system-level" operation from regular transactions.
The separation simplifies testing (so facilitates security) by reducing interaction effects generated by mixing this system-level concern with user data.

## Specification

| constants                     | value                                          | units
|---                            |---                                             |---
| `FORK_TIMESTAMP`              | TBD                                            |

Beginning with the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** introduce the following extensions to transaction processing and block validation:

### System-level operation: withdrawal

Define a new block-level object called a `withdrawal` that describes withdrawals that have been validated at the consensus layer.
`Withdrawal`s are syntactically like a user-level transaction but by virtue of a separate type live in a domain different than user-level transactions.

`Withdrawal`s have three key pieces of information supplied from the consensus layer:
1. a monotonically increasing `index` as a `uint64` value
2. a recipient for the withdrawn ether `address` as a 20-byte value
3. an `amount` of ether given in wei as a 256-bit value.

`Withdrawal` objects are serialized using RLP according to the schema: `RLP([index, address, amount])`.

### New field in the execution block: withdrawals

The execution block gains a new field referred to as `withdrawals`.

The `block.withdrawals` are encoded as an RLP list of `Withdrawal` objects.

For example:

```python
withdrawal_0 = RLP([index_0, address_0, amount_0])
withdrawal_1 = RLP([index_1, address_1, amount_1])
withdrawals = RLP([withdrawal_0, withdrawal_1])
block.withdrawals = withdrawals
```

### Commitment to withdrawals

The execution block header gains a new field committing to the `withdrawals` in the block.

This commitment is constructed identically to the transactions root in the existing block header by inserting each withdrawal into a Merkle-Patricia trie keyed by index in the list of `withdrawals`.

```python
def compute_trie_root_from_indexed_data(data):
    trie = Trie.from([(i, obj) for i, obj in enumerate(data)])
    return trie.root

block_header.withdrawals_root = compute_trie_root_from_indexed_data(block.withdrawals)
```

### Block validity

Assuming the block is well-formatted, the execution client has an additional block validation to ensure that the `withdrawals_root` matches the expected value given the list present in the block.

```python
assert block_header.withdrawals_root == compute_trie_root_from_indexed_data(block.withdrawals)
```

### State transition

The `withdrawals` in a block are processed **after** any user-level transactions are applied.

For each `withdrawal` in the list of `block.withdrawals`, the implementation should increase the balance of the `address` specified by the `amount` given.

This balance change is unconditional and **MUST** not fail.

This operation has no associated gas costs.

TODO: add logs? this implies receipt structure for the withdrawals and a commitment to the list of receipts

## Rationale

### Why not a new transaction type?

This EIP suggests a new type of object -- the "operation" -- as it has special semantics different from other existing types of EVM transactions.

An entirely new type of objecct firewalls off generic EVM execution from this type of processing to simplify testing and security review of withdrawals.

### Why no (gas) costs for new transaction type?

The maximum number of this transaction type that can reach the execution layer at a given time is bounded (enforced by the consensus layer) and this limit is kept small so that
any execution layer operational costs are negligible in the context of the broader block execution.

### Why only balance updates? No general EVM execution?

More general processing introduces the risk of failures, which complicates accounting on the beacon chain.

This EIP suggests a route for withdrawals that provides most of the benefits for a minimum of the (complexity) cost.

## Backwards Compatibility

No issues.

## Security Considerations

Consensus-layer validation of withdrawal transactions is critical to ensure that the proper amount of ETH is withdrawn back into the execution layer.
This consensus-layer to execution-layer ETH transfer does not have a current analog in the EVM and thus deserves very high security scrutiny.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
